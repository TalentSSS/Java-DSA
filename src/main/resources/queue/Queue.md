## 队列

### ADT

队列ADT首先支持两个基本方法

| 操作方法   | 功能描述                                                     |
| ---------- | ------------------------------------------------------------ |
| enqueue(x) | 将元素x加到队列末端<br>输入：一个对象<br>输出：无            |
| dequeue()  | 若队列非空，移除队首元素并返回<br>否则，报空队列异常<br>输入：无<br>输出：对象 |

一个更加好用的队列ADT还应该支持如下方法

| 操作方法  | 功能描述                                                     |
| --------- | ------------------------------------------------------------ |
| getSize() | 返回队列中当前包含的元素数目                                 |
| isEmpty() | 检查队列是否为空<br>输入：无<br>输出：bool标志               |
| front()   | 若队列非空，则返回队首元素(但不移除)<br>否则，报空队列异常<br>输入：无<br>输出：队头对象 |

接口定义详见[Queue.java](../../java/dsa/queue/Queue.java)

### 基于数组实现

#### 顺序数组

一种思路是仿照栈的实现，以Q[0]为队首，其他对象往后放。但这样每次出队，所有后面元素都要往前移动，如果队长是n，就需要O(n)时间，效率低

#### 循环数组

在顺序数组的基础上，避免数组整体移动，引入f和r：

f：front，Q的首元素的数组下标，**下次出队**元素的位置

r：rear，Q的**末元素下标加一**，**下次入队**元素的位置

在f=r=0时，队列空；有对象入队时，存放于Q[r]，然后r加一指向下一单元；每次有对象出队后，f也加一，指向新队首元素。

按照上述约定，f与r始终在单调增加，因此f与r必然会超出有限的数组容量范围。解决方法就是在每次f或r加一后，都要**以数组长度做取模运算**。即把数组的头和尾相连，构成一个**环状结构**。具体实现请看[QueueArray.java](../../java/dsa/queue/array/QueueArray.java)

#### 队空与队满

QueueArray用的是定长数组，有可能出现**空间溢出**的情况。在出现空间溢出时要抛QueueFullException异常。对空队列的出队操作也应当抛QueueEmptyException异常。

在队列不含任何对象时，有f=r。但当f=r时，也有可能对应**队列全满**的情况。

考虑：**在数组中只有一个空闲单元，插入后有f=r**，但实际上队列已满。但先前有约定f=r时队列为空，尽管队列中有元素，但无法进行出队操作；而且尽管空间满了，却还能再插入新元素。

解决这一问题最简单的方法就是，**禁止队列的实际规模超过N-1**。超了就抛QueueFullException。

#### 性能分析

以上实现的队列，每一方法都只需要执行常数次算术运算、比较及赋值操作，运行时间都是O(1)。
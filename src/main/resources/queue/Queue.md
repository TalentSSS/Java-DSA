## 队列

### ADT

队列ADT首先支持两个基本方法

| 操作方法   | 功能描述                                                     |
| ---------- | ------------------------------------------------------------ |
| enqueue(x) | 将元素x加到队列末端<br>输入：一个对象<br>输出：无            |
| dequeue()  | 若队列非空，移除队首元素并返回<br>否则，报空队列异常<br>输入：无<br>输出：对象 |

一个更加好用的队列ADT还应该支持如下方法

| 操作方法  | 功能描述                                                     |
| --------- | ------------------------------------------------------------ |
| getSize() | 返回队列中当前包含的元素数目                                 |
| isEmpty() | 检查队列是否为空<br>输入：无<br>输出：bool标志               |
| front()   | 若队列非空，则返回队首元素(但不移除)<br>否则，报空队列异常<br>输入：无<br>输出：队头对象 |

接口定义详见[Queue.java](../../java/dsa/queue/Queue.java)

### 基于数组实现

#### 顺序数组

一种思路是仿照栈的实现，以$Q[0]$为队首，其他对象往后放。但这样每次出队，所有后面元素都要往前移动，如果队长是$n$，就需要$O(n)$时间，效率低

#### 循环数组

在顺序数组的基础上，避免数组整体移动，引入$f$和$r$：

$f$：front，Q的首元素的数组下标，**下次出队**元素的位置

$r$：rear，Q的**末元素下标加一**，**下次入队**元素的位置

在$f=r=0$时，队列空；有对象入队时，存放于$Q[r]$，然后$r$加一指向下一单元；每次有对象出队后，$f$也加一，指向新队首元素。

按照上述约定，$f$与$r$始终在单调增加，因此$f$与$r$必然会超出有限的数组容量范围。解决方法就是在每次$f$或$r$加一后，都要**以数组长度做取模运算**。即把数组的头和尾相连，构成一个**环状结构**。具体实现请看[QueueList.java](../../java/dsa/queue/list/QueueList.java)


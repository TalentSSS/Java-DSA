## 队列

### ADT

队列ADT首先支持两个基本方法

| 操作方法   | 功能描述                                                     |
| ---------- | ------------------------------------------------------------ |
| enqueue(x) | 将元素x加到队列末端<br>输入：一个对象<br>输出：无            |
| dequeue()  | 若队列非空，移除队首元素并返回<br>否则，报空队列异常<br>输入：无<br>输出：对象 |

一个更加好用的队列ADT还应该支持如下方法

| 操作方法  | 功能描述                                                     |
| --------- | ------------------------------------------------------------ |
| getSize() | 返回队列中当前包含的元素数目                                 |
| isEmpty() | 检查队列是否为空<br>输入：无<br>输出：bool标志               |
| front()   | 若队列非空，则返回队首元素(但不移除)<br>否则，报空队列异常<br>输入：无<br>输出：队头对象 |

接口定义详见[Queue.java](../../java/dsa/queue/Queue.java)

### 基于数组实现

#### 顺序数组

一种思路是仿照栈的实现，以Q[0]为队首，其他对象往后放。但这样每次出队，所有后面元素都要往前移动，如果队长是n，就需要O(n)时间，效率低

#### 循环数组

在顺序数组的基础上，避免数组整体移动，引入f和r：

f：front，Q的首元素的数组下标，**下次出队**元素的位置

r：rear，Q的**末元素下标加一**，**下次入队**元素的位置

在f=r=0时，队列空；有对象入队时，存放于Q[r]，然后r加一指向下一单元；每次有对象出队后，f也加一，指向新队首元素。

按照上述约定，f与r始终在单调增加，因此f与r必然会超出有限的数组容量范围。解决方法就是在每次f或r加一后，都要**以数组长度做取模运算**。即把数组的头和尾相连，构成一个**环状结构**。具体实现请看[QueueArray.java](../../java/dsa/queue/array/QueueArray.java)

#### 队空与队满

QueueArray用的是定长数组，有可能出现**空间溢出**的情况。在出现空间溢出时要抛QueueFullException异常。对空队列的出队操作也应当抛QueueEmptyException异常。

在队列不含任何对象时，有f=r。但当f=r时，也有可能对应**队列全满**的情况。

考虑：**在数组中只有一个空闲单元，插入后有f=r**，但实际上队列已满。但先前有约定f=r时队列为空，尽管队列中有元素，但无法进行出队操作；而且尽管空间满了，却还能再插入新元素。

解决这一问题最简单的方法就是，**禁止队列的实际规模超过N-1**。超了就抛QueueFullException。

#### 性能分析

以上实现的队列，每一方法都只需要执行常数次算术运算、比较及赋值操作，运行时间都是O(1)。

### 基于单链表实现队列

出于效率方面的考虑，以单链表的首(末)节点作为队列的首(末节点)，从而回避单链表在尾部进行操作时效率低下的缺陷。用两个实例变量分别表示表的首、末节点。

具体实现请看[QueueList.java](../../java/dsa/queue/list/QueueList.java)

如上实现的各个队列ADT方法都可以在O(1)时间内完成。受单链表限制，我们仍然需要对各种特殊情况(如队空时)专门处理。

### 队列的应用

* 循环分配器

    队列结构很适合用来实现循环分配器：按照环形次序反复循环，为共享某一资源的一群用户做资源分配，如共享一个CPU的多个应用程序。

    借助队列实现循环分配器

    > 算法：RoundRobin
    >
    > {
    >
    > > e = Q.dequeue();
    > >
    > > Serve(e);
    > >
    > > Q.enqueue(e);
    >
    > }

* Josephus环

    烫手山芋游戏，n个小孩围成一圈，从1开始，数到k时让拿着山芋的孩子出来，重新从1开始数到k，找最后的幸运者。

    解决这个问题可以利用队列结构来表示围成一圈的n个孩子。假设队列首节点的那个孩子拿着山芋，将"土豆"向后传递到第k个孩子，即交替进行k次dequeue()和k次enqueue()操作，让第k个孩子出队。如此迭代，最后让队长为1。

    具体实现请看[Josephus.java](../../java/dsa/queue/array/occasion/Josephus.java)
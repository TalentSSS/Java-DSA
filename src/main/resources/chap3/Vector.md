## 向量与数组

支持通过秩直接访问其中元素的序列，称作向量(Vector)或数组列表(Array list)。

秩可以直接指定插入或删除元素的位置。

秩不仅表示元素的位置，也表示前驱节点的个数。

### ADT

向量ADT

| 操作方法            | 功能描述                                                     |
| ------------------- | ------------------------------------------------------------ |
| getSize()           | 报告向量中的元素数目<br>输入：无<br>输出：非负整数           |
| isEmpty()           | 判断向量是否为空<br>输入：无<br>输出：布尔量                 |
| getAtRank(r)        | 若0 <= r < getSize()，则返回秩为r的那个元素<br>否则，报错<br>输入：一个整数<br>输出：对象 |
| replaceAtRank(r, e) | 若0 <= r < getSize()，则将秩为r的元素替换为e，并返回原来的元素<br>否则，报错<br>输入：一个整数和一个对象<br>输出：对象 |
| insertAtRank(r, e)  | 若0 <= r < getSize()，则将e插入向量中，作为秩为r的元素（原秩不小于r的元素顺次后移）；并返回该元素<br>否则，报错<br>输入：一个整数和一个对象<br>输出：对象 |
| removeAtRank(r)     | 若0 <= r < getSize()，则删除秩为r的那个元素并返回之（原秩大于r的元素顺次前移）<br>否则，报错<br>输入：一个整数<br>输出：对象 |

* 秩越界异常

    当作为参数的秩越界时，应当抛出异常，代码见[BoundaryViolationException.java](../../java/dsa/vector/BoundaryViolationException.java)

* 向量接口

    代码见[Vector.java](../../java/dsa/vector/Vector.java)

### 基于数组的简单实现

思路就是借用数组A[]，其中A[i]分别存放一个引用，指向秩为i的向量元素，注意A[]的容量N要足够大。

代码见[VectorArray.java](../../java/dsa/vector/impl/VectorArray.java)

### 基于可扩充数组的实现

如上的简单实现有个缺陷——数组容量N固定。

向量规模小，会有空间浪费；向量规模太大超过N，即使系统资源够，结构也会崩溃。

因此向量最好能够根据实际需要，动态扩充容量。

处理的方法是，一旦空间溢出，就进行如下处理

> 1. 开辟一个容量为2N的新数组B
> 2. 将A[]中各元素搬迁至B[]，即B[i]=A[i]，i=0, …, N-1
> 3. 将A替换为B，即令A=B

原先数组占用的空间会因为没有引用指向它而被GC自动回收。

具体实现见[VectorExtArray.java](../../java/dsa/vector/impl/VectorExtArray.java)

* 分摊时间复杂度分析

    简单数组可以更高效利用空间，不会受到数组容量限制。

    但每次扩容时，需要花费的时间将数组内容复制到新数组；假设原数组容量为N，将数组容量由N扩大到2N需要$O(n)$的时间。

    由于无法确定扩容操作的执行，因此无法采用通常的方法来度量和分析复杂度。

    引入**分摊复杂度**的概念

    > **分摊复杂度**：在连续执行足够多次操作中，每次操作所需的平均时间。

    注意将分摊复杂度(Amortized time)与平均时间(Average running time)的区别。前者是指整个算法在某种概率分布输入下的平均运行时间；后者是指在反复使用某个算法及其数据结构，连续足够多次运行所需时间的平均值。

    对于这类的可扩充数组，只需要考虑这一结构的连续n次操作，将每次操作所需时间累计，除以n，只要n足够大，平均时间就是分摊运行时间。

    > 结论：基于可扩充数组实现的向量，每次数组扩容的分摊运行时间为$O(1)$

    该结论的证明见课本。

